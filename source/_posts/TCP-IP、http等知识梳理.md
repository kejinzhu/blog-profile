---
title: TCP/IP、http等知识梳理
date: 2018-08-15 08:52:51
toc: true
tags:
    - http、TCP/IP
    - 前后端通信
---

# 前后端通信
先从一道面试题开始：
在面试的时候经常被问，当我们在浏览器地址栏中输入一个URL地址,到最后看到页面,中间都经历了哪些事情?
我们从客户端和服务器交互模型角度来回答这个问题：
假设我们访问的是 https://www.baidu.com/这个地址 ，回车键之后，我们可以看到的百度页面
<!-- more -->
- 百度页面并没用在我们自己的客户端本地，我们输入地址之后，才请求过来的
- 输入不同的域名可以看到不同的页面
- 有的网址是https:,有的是http(也有ftp)
- 需要客户端联网才能完成这些事情
那这一过程都经历了什么事情呢？

## request请求阶段

- 首先根据客户端输入的域名，到DNS服务器上进行反解析(通过域名找到对应服务器的外网IP)
- 通过找到的外网IP，找到对应的服务器
- 通过在地址栏中输入的端口号(没有输入时因为不同协议有自己默认的端口号)找到服务器上发布的对应的项目

## response响应阶段

- 真正的服务器接收到响应，根据你的请求信息，进行资源的整理；并且把相应的资源通过HTTP返给客户端；(html,css，js返回的不是文件)
- 把从服务器请求过来的数据，资源进行整理；处理成浏览器可识别的文件；

## 浏览器自主渲染的过程

- 先把HTML文件进行过滤解析，形成DOM树；节点与节点之间的一个组合
- 代码从上到下解析，形成CSS树；
- 把DOM树和css树进行重新组合，形成render树；是真正最后渲染的树；

我们上面说的协议，一般有HTTP、TCP、IP等
那协议是什么呢？协议的必要性在哪？

- 简单来说，协议就是计算机与计算机之间通过网络通信时，事先达成的一种 “约定”。这种“约定”使不同厂商的设备、不同的CPU以及不同操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。这就好比一个中国人说汉语一个外国人说英语使用不同的国家语言进行沟通，怎么也无法理解。如果两个人约定好 都说中文或英文，就可以互相沟通通信。协议分为很多种，每一种协议都明确界定了它的行为规范。两台计算机必须能够支持相同的协议，并遵循相同协议进行处理，这样才能实现相互通信。

# TCP/IP协议

**TCP/IP** 是用于因特网 (Internet) 的通信协议。 TCP/IP 通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。

- TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复 用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性、 流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。 TCP支持的应用协议主要有：Telnet、FTP、SMTP等； UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。 TCP/IP协议与低层的数据链路层和物理层无关，这也是TCP/IP的重要特点
TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:

## 三次握手的过程

- 第一次握手：客户端发送SYN码数据包发送给服务器，客户端要求和服务器建立连接
- 第二次握手：服务端接收到联机请求会发送ACK码到客户端，是要建立联机吗？
- 第三次握手：客户端接收到服务端的ACK码，验证是否正确，如果正确，则再次发送ACK，建立连接
- 三次握手之后，客户端和服务端联机成功，可以发送数据

一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的 描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同 步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数 据。

![三次握手过程](/images/三次握手.jpg)

客户端和服务端发送数据是双向的；客户端给服务端传递的是路径、参数，随机的；服务端给客户端传输自己的资源，文件，数据；

## 四次挥手的过程

- 1.当客户端发送数据结束，需要发送fin告诉服务器，数据传输结束；
- 2.服务端返回给客户端一个ACK码，知道客户端数据传输完毕；客户端接收到ACK，就会把发送到服务端的通道进行关闭；
- 3.服务端数据传输结束之后，也会发送fin给客户端
- 4.当客户端接收数据完毕之后，会发送ACK给服务端，服务端可以安心关闭传输数据的通道。

当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1, 服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。 A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。

![四次挥手过程](/images/四次挥手.jpg)

## 为什么需要等待呢？

为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）
另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？ 就是保活时间到了后，B会发送探测信息， 以决定是否释放连接

## 为什么握手是三次，挥手是四次的呢？

- 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。




